/*!
 * Note: This code is derived from auto-generated sources but modified for randomization and comment removal.
 * Original source: https://github.com/berstend/puppeteer-extra/tree/master/packages/extract-stealth-evasions
 * Generation Date: Sat, 06 Aug 2022 22:10:53 GMT
 * License: MIT
 */
(() => {
    // 最简单的方式（需要较新浏览器）
    const uuid = crypto.randomUUID();
// 示例: '1a2b3c4d-5e6f-7890-1234-567890abcdef'
  const fingerprintProfiles = [

          {
      // Profile based on provided test results (Android 10, Mobile Chrome 135, Adreno 750)
      userAgent: `Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${uuid}.0.0.0 Mobile Safari/537.36`,
      languages: ['en-US', 'zh-CN', 'en'],
      hardwareConcurrency: 8, // Common for higher-end mobile SoCs
      deviceMemory: 8,        // From fp-collect results
      webglVendor: 'Qualcomm',
      webglRenderer: 'Adreno (TM) 750',
      outerHeightOffset: 0,   // Mobile browsers typically don't have the same fixed offset as desktop
      plugins: [],            // Mobile Chrome reports 0 plugins
      mimeTypes: []           // Corresponds to 0 plugins
    },
      {
      // Profile based on provided test results (Windows, Chrome 130 variant, RTX 3060 Laptop)
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36 QuarkPC/2.5.0.299',
      languages: ['zh-CN', 'zh'],
      hardwareConcurrency: 8, // Estimated based on device memory
      deviceMemory: 8,        // From fp-collect results
      webglVendor: 'Google Inc. (NVIDIA)',
      webglRenderer: 'ANGLE (NVIDIA, NVIDIA GeForce RTX 3060 Laptop GPU (0x00002560) Direct3D11 vs_5_0 ps_5_0, D3D11)',
      outerHeightOffset: 127, // Calculated from wOuterHeight - wInnerHeight (1151 - 1024)
      // NOTE: Using standard plugin/mimeType structure generated by the script,
      // as the 5 reported PDF plugins are unusual and likely an artifact of the test/environment.
      // Mimicking standard Chrome plugins is generally preferred for evasion.
      plugins: [
         {name:"Chrome PDF Plugin",filename:"internal-pdf-viewer",description:"Portable Document Format",__mimeTypes:["application/x-google-chrome-pdf"]},
         {name:"Chrome PDF Viewer",filename:"mhjfbmdgcfjbbpaeojofohoefgiehjai",description:"",__mimeTypes:["application/pdf"]}, // Standard name used in script
         {name:"Native Client",filename:"internal-nacl-plugin",description:"",__mimeTypes:["application/x-nacl","application/x-pnacl"]}
       ],
       mimeTypes: [
         {type:"application/pdf",suffixes:"pdf",description:"",__pluginName:"Chrome PDF Viewer"}, // Linked to standard name
         {type:"application/x-google-chrome-pdf",suffixes:"pdf",description:"Portable Document Format",__pluginName:"Chrome PDF Plugin"},
         {type:"application/x-nacl",suffixes:"",description:"Native Client Executable",__pluginName:"Native Client"},
         {type:"application/x-pnacl",suffixes:"",description:"Portable Native Client Executable",__pluginName:"Native Client"}
       ]
    },
    {
      // Profile 1: Common Windows Chrome
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
      languages: ['en-US', 'en'],
      hardwareConcurrency: 8,
      deviceMemory: 8, // Added Device Memory
      webglVendor: 'Google Inc. (Intel)',
      webglRenderer: 'ANGLE (Intel, Intel(R) UHD Graphics 630 Direct3D11 vs_5_0 ps_5_0, D3D11)',
      outerHeightOffset: 85,
      plugins: [
         {name:"Chrome PDF Plugin",filename:"internal-pdf-viewer",description:"Portable Document Format",__mimeTypes:["application/x-google-chrome-pdf"]},
         {name:"Chrome PDF Viewer",filename:"mhjfbmdgcfjbbpaeojofohoefgiehjai",description:"",__mimeTypes:["application/pdf"]},
         {name:"Native Client",filename:"internal-nacl-plugin",description:"",__mimeTypes:["application/x-nacl","application/x-pnacl"]}
       ],
       mimeTypes: [
         {type:"application/pdf",suffixes:"pdf",description:"",__pluginName:"Chrome PDF Viewer"},
         {type:"application/x-google-chrome-pdf",suffixes:"pdf",description:"Portable Document Format",__pluginName:"Chrome PDF Plugin"},
         {type:"application/x-nacl",suffixes:"",description:"Native Client Executable",__pluginName:"Native Client"},
         {type:"application/x-pnacl",suffixes:"",description:"Portable Native Client Executable",__pluginName:"Native Client"}
       ]
    },
    {
      // Profile 2: Common MacOS Chrome
      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36',
      languages: ['en-GB', 'en'],
      hardwareConcurrency: 10,
      deviceMemory: 16, // Added Device Memory
      webglVendor: 'Google Inc. (Apple)',
      webglRenderer: 'ANGLE (Apple, Apple M1 Pro, Metal)',
      outerHeightOffset: 80,
      plugins: [
         {name:"Chrome PDF Plugin",filename:"internal-pdf-viewer",description:"Portable Document Format",__mimeTypes:["application/x-google-chrome-pdf"]},
         {name:"Chrome PDF Viewer",filename:"mhjfbmdgcfjbbpaeojofohoefgiehjai",description:"",__mimeTypes:["application/pdf"]},
         {name:"Native Client",filename:"internal-nacl-plugin",description:"",__mimeTypes:["application/x-nacl","application/x-pnacl"]}
       ],
       mimeTypes: [
         {type:"application/pdf",suffixes:"pdf",description:"",__pluginName:"Chrome PDF Viewer"},
         {type:"application/x-google-chrome-pdf",suffixes:"pdf",description:"Portable Document Format",__pluginName:"Chrome PDF Plugin"},
         {type:"application/x-nacl",suffixes:"",description:"Native Client Executable",__pluginName:"Native Client"},
         {type:"application/x-pnacl",suffixes:"",description:"Portable Native Client Executable",__pluginName:"Native Client"}
       ]
    },
    {
      // Profile 3: Slightly different Windows Chrome
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36',
      languages: ['de-DE', 'de', 'en-US', 'en'],
      hardwareConcurrency: 4,
      deviceMemory: 4, // Added Device Memory
      webglVendor: 'Google Inc. (NVIDIA)',
      webglRenderer: 'ANGLE (NVIDIA, NVIDIA GeForce RTX 3060 Direct3D11 vs_5_0 ps_5_0, D3D11-alt)',
      outerHeightOffset: 90,
       plugins: [
         {name:"Chrome PDF Plugin",filename:"internal-pdf-viewer",description:"Portable Document Format",__mimeTypes:["application/x-google-chrome-pdf"]},
         {name:"Chrome PDF Viewer",filename:"mhjfbmdgcfjbbpaeojofohoefgiehjai",description:"",__mimeTypes:["application/pdf"]},
         {name:"Native Client",filename:"internal-nacl-plugin",description:"",__mimeTypes:["application/x-nacl","application/x-pnacl"]},
         {name:"Shockwave Flash", filename:"pepflashplayer.dll", description:"Shockwave Flash 32.0 r0", __mimeTypes:["application/x-shockwave-flash", "application/futuresplash"]}
       ],
       mimeTypes: [
         {type:"application/pdf",suffixes:"pdf",description:"",__pluginName:"Chrome PDF Viewer"},
         {type:"application/x-google-chrome-pdf",suffixes:"pdf",description:"Portable Document Format",__pluginName:"Chrome PDF Plugin"},
         {type:"application/x-nacl",suffixes:"",description:"Native Client Executable",__pluginName:"Native Client"},
         {type:"application/x-pnacl",suffixes:"",description:"Portable Native Client Executable",__pluginName:"Native Client"},
         {type:"application/x-shockwave-flash", suffixes:"swf", description:"Shockwave Flash", __pluginName:"Shockwave Flash"},
         {type:"application/futuresplash", suffixes:"spl", description:"FutureSplash Player", __pluginName:"Shockwave Flash"}
       ]
    },
    {
      // Profile 4: Linux Chrome
      userAgent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
      languages: ['en-US', 'en', 'fr-FR', 'fr'],
      hardwareConcurrency: 12,
      deviceMemory: 16, // Added Device Memory
      webglVendor: 'Google Inc. (AMD)',
      webglRenderer: 'ANGLE (AMD, AMD Radeon RX 6800 XT (navi21, LLVM 15.0.7, DRM 3.49, 6.1.9-arch1-1), OpenGL 4.6)',
      outerHeightOffset: 75, // Linux offsets can vary
      plugins: [ // Often similar to Windows/Mac default
         {name:"Chrome PDF Plugin",filename:"internal-pdf-viewer",description:"Portable Document Format",__mimeTypes:["application/x-google-chrome-pdf"]},
         {name:"Chrome PDF Viewer",filename:"mhjfbmdgcfjbbpaeojofohoefgiehjai",description:"",__mimeTypes:["application/pdf"]},
         {name:"Native Client",filename:"internal-nacl-plugin",description:"",__mimeTypes:["application/x-nacl","application/x-pnacl"]}
       ],
       mimeTypes: [
         {type:"application/pdf",suffixes:"pdf",description:"",__pluginName:"Chrome PDF Viewer"},
         {type:"application/x-google-chrome-pdf",suffixes:"pdf",description:"Portable Document Format",__pluginName:"Chrome PDF Plugin"},
         {type:"application/x-nacl",suffixes:"",description:"Native Client Executable",__pluginName:"Native Client"},
         {type:"application/x-pnacl",suffixes:"",description:"Portable Native Client Executable",__pluginName:"Native Client"}
       ]
    }
  ];

  let selectedProfile = fingerprintProfiles[Math.floor(Math.random() * fingerprintProfiles.length)];
  selectedProfile=fingerprintProfiles[0]
  const _utilsFns = {
    init: "() => {\n  utils.preloadCache()\n}",
    stripProxyFromErrors: "(handler = {}) => {\n  const newHandler = {\n    setPrototypeOf: function (target, proto) {\n      if (proto === null)\n        throw new TypeError('Cannot convert object to primitive value')\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) {\n        throw new TypeError('Cyclic __proto__ value')\n      }\n      return Reflect.setPrototypeOf(target, proto)\n    }\n  }\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap => {\n    newHandler[trap] = function () {\n      try {\n        return handler[trap].apply(this, arguments || [])\n      } catch (err) {\n        if (!err || !err.stack || !err.stack.includes(`at `)) {\n          throw err\n        }\n        const stripWithBlacklist = (stack, stripFirstLine = true) => {\n          const blacklist = [\n            `at Reflect.${trap} `, \n            `at Object.${trap} `, \n            `at Object.newHandler.<computed> [as ${trap}] ` \n          ]\n          return (\n            err.stack\n              .split('\\n')\n              .filter((line, index) => !(index === 1 && stripFirstLine))\n              .filter(line => !blacklist.some(bl => line.trim().startsWith(bl)))\n              .join('\\n')\n          )\n        }\n        const stripWithAnchor = (stack, anchor) => {\n          const stackArr = stack.split('\\n')\n          anchor = anchor || `at Object.newHandler.<computed> [as ${trap}] ` \n          const anchorIndex = stackArr.findIndex(line =>\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) {\n            return false \n          }\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join('\\n')\n        }\n        err.stack = err.stack.replace(\n          'at Object.toString (',\n          'at Function.toString ('\n        )\n        if ((err.stack || '').includes('at Function.toString (')) {\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        }\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n        throw err \n      }\n    }\n  })\n  return newHandler\n}",
    stripErrorWithAnchor: "(err, anchor) => {\n  const stackArr = err.stack.split('\\n')\n  const anchorIndex = stackArr.findIndex(line => line.trim().startsWith(anchor))\n  if (anchorIndex === -1) {\n    return err \n  }\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join('\\n')\n  return err\n}",
    replaceProperty: "(obj, propName, descriptorOverrides = {}) => {\n  return Object.defineProperty(obj, propName, {\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),\n    ...descriptorOverrides\n  })\n}",
    preloadCache: "() => {\n  if (utils.cache) {\n    return\n  }\n  utils.cache = {\n    Reflect: {\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    },\n    nativeToStringStr: Function.toString + '' \n  }\n}",
    makeNativeString: "(name = '') => {\n  try { return utils.cache.nativeToStringStr.replace('toString', name || '') } catch(e) { return 'function '+name+'() { [native code] }' }\n}", // Added try-catch for robustness
    patchToString: "(obj, str = '') => {\n  const handler = {\n    apply: function (target, ctx) {\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      if (ctx === obj) {\n        return str || utils.makeNativeString(obj && obj.name ? obj.name : '')\n      }\n      let hasSameProto = false;\n       try {\n         hasSameProto = Object.getPrototypeOf(\n           Function.prototype.toString\n         ).isPrototypeOf(ctx.toString)\n      } catch(e){}\n      if (!hasSameProto) {\n        try { return ctx.toString() } catch(e) { return '' }\n      }\n       try { return target.call(ctx) } catch(e) { return '' }\n    }\n  }\n  try {\n      const toStringProxy = new Proxy(\n        Function.prototype.toString,\n        utils.stripProxyFromErrors(handler)\n      )\n      utils.replaceProperty(Function.prototype, 'toString', {\n        value: toStringProxy\n      })\n  } catch (e) {}\n}",
    patchToStringNested: "(obj = {}) => {\n  return utils.execRecursively(obj, ['function'], utils.patchToString)\n}",
    redirectToString: "(proxyObj, originalObj) => {\n  const handler = {\n    apply: function (target, ctx) {\n      if (ctx === Function.prototype.toString) {\n        return utils.makeNativeString('toString')\n      }\n      if (ctx === proxyObj) {\n        const fallback = () =>\n          originalObj && originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj && proxyObj.name ? proxyObj.name : '')\n        try { return originalObj + '' || fallback() } catch(e) { return fallback() }\n      }\n      if (typeof ctx === 'undefined' || ctx === null) {\n         try { return target.call(ctx) } catch(e) { return ''}\n      }\n       let hasSameProto = false;\n       try {\n           hasSameProto = Object.getPrototypeOf(\n                Function.prototype.toString\n            ).isPrototypeOf(ctx.toString)\n       } catch(e){}\n      if (!hasSameProto) {\n         try { return ctx.toString() } catch(e) { return '' }\n      }\n       try { return target.call(ctx) } catch(e) { return ''}\n    }\n  }\n  try {\n      const toStringProxy = new Proxy(\n        Function.prototype.toString,\n        utils.stripProxyFromErrors(handler)\n      )\n      utils.replaceProperty(Function.prototype, 'toString', {\n        value: toStringProxy\n      })\n  } catch (e) {}\n}",
    replaceWithProxy: "(obj, propName, handler) => {\n  try {\n      const originalObj = obj[propName]\n      const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n      utils.replaceProperty(obj, propName, { value: proxyObj })\n      utils.redirectToString(proxyObj, originalObj)\n      return true\n  } catch (e) { return false; }\n}",
    replaceGetterWithProxy: "(obj, propName, handler) => {\n try {\n      const fn = Object.getOwnPropertyDescriptor(obj, propName)?.get;\n      if(!fn) return false;\n      const fnStr = fn.toString() \n      const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n      utils.replaceProperty(obj, propName, { get: proxyObj })\n      utils.patchToString(proxyObj, fnStr)\n      return true\n } catch(e) { return false; }\n}",
    replaceGetterSetter: "(obj, propName, handlerGetterSetter) => {\n try {\n      const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n       if(!ownPropertyDescriptor) return;\n      const handler = { ...ownPropertyDescriptor }\n      if (handlerGetterSetter.get !== undefined) {\n        const nativeFn = ownPropertyDescriptor.get\n        if(!nativeFn) return;\n        handler.get = function() {\n          try { return handlerGetterSetter.get.call(this, nativeFn.bind(this)) } catch(e) { return undefined; }\n        }\n        utils.redirectToString(handler.get, nativeFn)\n      }\n      if (handlerGetterSetter.set !== undefined) {\n        const nativeFn = ownPropertyDescriptor.set\n        if(!nativeFn) return;\n        handler.set = function(newValue) {\n          try { handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this)) } catch(e) {} \n        }\n        utils.redirectToString(handler.set, nativeFn)\n      }\n      Object.defineProperty(obj, propName, handler)\n } catch(e) {}\n}",
    mockWithProxy: "(obj, propName, pseudoTarget, handler) => {\n try {\n      const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n      utils.replaceProperty(obj, propName, { value: proxyObj })\n      utils.patchToString(proxyObj)\n      return true\n } catch(e) { return false; }\n}",
    createProxy: "(pseudoTarget, handler) => {\n try {\n      const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n      utils.patchToString(proxyObj)\n      return proxyObj\n } catch(e) { return pseudoTarget; }\n}", // Return original target on error
    splitObjPath: "objPath => ({\n  objName: objPath.split('.').slice(0, -1).join('.'),\n  propName: objPath.split('.').slice(-1)[0]\n})",
    replaceObjPathWithProxy: "(objPath, handler) => {\n try {\n      const { objName, propName } = utils.splitObjPath(objPath)\n      const obj = eval(objName) \n      return utils.replaceWithProxy(obj, propName, handler)\n } catch(e) { return false; }\n}",
    execRecursively: "(obj = {}, typeFilter = [], fn) => {\n  function recurse(obj) {\n    for (const key in obj) {\n      try {\n          if (obj[key] === undefined || obj[key] === null) {\n            continue\n          }\n          if (obj[key] && typeof obj[key] === 'object') {\n            recurse(obj[key])\n          } else {\n            if (obj[key] && typeFilter.includes(typeof obj[key])) {\n              fn.call(this, obj[key])\n            }\n          }\n      } catch(e) {}\n    }\n  }\n  try{ recurse(obj) } catch(e) {} \n  return obj\n}",
    stringifyFns: "(fnObj = { hello: () => 'world' }) => {\n  function fromEntries(iterable) {\n    return [...iterable].reduce((obj, [key, val]) => {\n      obj[key] = val\n      return obj\n    }, {})\n  }\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) => typeof value === 'function')\n      .map(([key, value]) => [key, value.toString()]) \n  )\n}",
    materializeFns: "(fnStrObj = { hello: \"() => 'world'\" }) => {\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) => {\n      try{\n          if (value.startsWith('function')) {\n            return [key, eval(`() => ${value}`)()] \n          } else {\n            return [key, eval(value)] \n          }\n      } catch(e) { return [key, function(){}] }\n    })\n  )\n}",
    makeHandler: "() => ({\n  getterValue: value => ({\n    apply(target, ctx, args) {\n      try{ utils.cache.Reflect.apply(...arguments) } catch(e) {}\n      return value\n    }\n  })\n})",
    arrayEquals: "(array1, array2) => {\n  if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length) {\n    return false\n  }\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false\n    }\n  }\n  return true\n}",
    memoize: "fn => {\n  const cache = []\n  return function(...args) {\n    let found = cache.find(c => utils.arrayEquals(c.key, args));\n    if (found) {\n         return found.value;\n    }\n    const value = fn.apply(this, args);\n    cache.push({ key: args, value: value });\n    return value;\n  }\n}"
  };


  const utils = Object.fromEntries(
    Object.entries(_utilsFns).map(([key, value]) => {
        try { return [key, eval(value)]; } catch(e) { console.error("Error evaluating util:", key, e); return [key, undefined]; }
    }).filter(entry => entry[1] !== undefined) // Filter out utils that failed to eval
  );
   if (utils.init) {
       utils.init();
   }


  const evasions = [
    {
      mainFunction: `(utils, profile) => {
          if (!window.chrome) {
             try {
                Object.defineProperty(window, 'chrome', {
                writable: true,
                enumerable: true,
                configurable: false,
                value: {}
                })
            } catch(e){}
          }
          if (window.chrome && 'app' in window.chrome) {
            return
          }
          const makeError = {
            ErrorInInvocation: fn => {
              const err = new TypeError(\`Error in invocation of app.\${fn}()\`)
              return utils.stripErrorWithAnchor(
                err,
                \`at \${fn} (eval at <anonymous>\`
              )
            }
          }
          const STATIC_DATA = JSON.parse(
            \`
    {
      "isInstalled": false,
      "InstallState": {
        "DISABLED": "disabled",
        "INSTALLED": "installed",
        "NOT_INSTALLED": "not_installed"
      },
      "RunningState": {
        "CANNOT_RUN": "cannot_run",
        "READY_TO_RUN": "ready_to_run",
        "RUNNING": "running"
      }
    }
            \`.trim()
          )
          try {
              window.chrome.app = {
                ...STATIC_DATA,
                get isInstalled() {
                  return false
                },
                getDetails: function getDetails() {
                  if (arguments.length) {
                    throw makeError.ErrorInInvocation(\`getDetails\`)
                  }
                  return null
                },
                getIsInstalled: function getDetails() {
                  if (arguments.length) {
                    throw makeError.ErrorInInvocation(\`getIsInstalled\`)
                  }
                  return false
                },
                runningState: function getDetails() {
                  if (arguments.length) {
                    throw makeError.ErrorInInvocation(\`runningState\`)
                  }
                  return 'cannot_run'
                }
              }
              utils.patchToStringNested(window.chrome.app)
          } catch(e) {}
        }`,
      args: []
    },
    {
      mainFunction: `(utils, profile) => {
          if (!window.chrome) {
             try{
                Object.defineProperty(window, 'chrome', {
                writable: true,
                enumerable: true,
                configurable: false,
                value: {}
                })
            } catch(e) {}
          }
          if (window.chrome && 'csi' in window.chrome) {
            return
          }
          if (!window.performance || !window.performance.timing) {
            return
          }
          const { timing } = window.performance
          try {
              window.chrome.csi = function() {
                return {
                  onloadT: timing.domContentLoadedEventEnd || 0,
                  startE: timing.navigationStart || 0,
                  pageT: Date.now() - (timing.navigationStart || Date.now()),
                  tran: 15
                }
              }
              utils.patchToString(window.chrome.csi)
          } catch(e){}
        }`,
      args: []
    },
    {
       mainFunction:`(utils, profile) => {
            if (!window.chrome) {
                 try {
                    Object.defineProperty(window, 'chrome', {
                    writable: true,
                    enumerable: true,
                    configurable: false,
                    value: {}
                    })
                 } catch(e){}
            }
            if (window.chrome && 'loadTimes' in window.chrome) {
              return
            }
            if (
              !window.performance ||
              !window.performance.timing ||
              typeof window.PerformancePaintTiming === 'undefined' // Check type existence
            ) {
              return
            }
            const { performance } = window
            const ntEntryFallback = {
              nextHopProtocol: 'h2',
              type: 'other'
            }
            const protocolInfo = {
              get connectionInfo() {
                 try {
                    const ntEntries = performance.getEntriesByType('navigation');
                    const ntEntry = ntEntries && ntEntries[0] ? ntEntries[0] : ntEntryFallback;
                    return ntEntry.nextHopProtocol || 'h2';
                 } catch(e) { return 'h2'; }
              },
              get npnNegotiatedProtocol() {
                 try {
                    const ntEntries = performance.getEntriesByType('navigation');
                    const ntEntry = ntEntries && ntEntries[0] ? ntEntries[0] : ntEntryFallback;
                    const protocol = ntEntry.nextHopProtocol || '';
                    return ['h2', 'hq'].includes(protocol) ? protocol : 'unknown'
                 } catch(e) { return 'unknown'; }
              },
              get navigationType() {
                 try {
                    const ntEntries = performance.getEntriesByType('navigation');
                    const ntEntry = ntEntries && ntEntries[0] ? ntEntries[0] : ntEntryFallback;
                    return ntEntry.type || 'navigate'; // Common default
                 } catch(e) { return 'navigate'; }
              },
              get wasAlternateProtocolAvailable() {
                return false
              },
              get wasFetchedViaSpdy() {
                 try {
                    const ntEntries = performance.getEntriesByType('navigation');
                    const ntEntry = ntEntries && ntEntries[0] ? ntEntries[0] : ntEntryFallback;
                    const protocol = ntEntry.nextHopProtocol || '';
                    return ['h2', 'hq'].includes(protocol);
                 } catch(e) { return false; }
              },
              get wasNpnNegotiated() {
                  try{
                    const ntEntries = performance.getEntriesByType('navigation');
                    const ntEntry = ntEntries && ntEntries[0] ? ntEntries[0] : ntEntryFallback;
                    const protocol = ntEntry.nextHopProtocol || '';
                    return ['h2', 'hq'].includes(protocol);
                  } catch(e) { return false; }
              }
            }
            const { timing } = window.performance
            function toFixed(num, fixed) {
              var re = new RegExp('^-?\\\\d+(?:.\\\\d{0,' + (fixed || -1) + '})?')
              try{
                  const numStr = (typeof num === 'number' || typeof num === 'string') ? num.toString() : '0';
                  const match = numStr.match(re);
                  return match ? match[0] : '0';
              } catch(e){
                  return '0';
              }
            }
            const timingInfo = {
              get firstPaintAfterLoadTime() {
                return 0
              },
              get requestTime() {
                return (timing.navigationStart || 0) / 1000
              },
              get startLoadTime() {
                return (timing.navigationStart || 0) / 1000
              },
              get commitLoadTime() {
                return (timing.responseStart || timing.navigationStart || 0) / 1000
              },
              get finishDocumentLoadTime() {
                 return (timing.domContentLoadedEventEnd || timing.loadEventEnd || 0) / 1000
              },
              get finishLoadTime() {
                return (timing.loadEventEnd || 0) / 1000
              },
              get firstPaintTime() {
                 try {
                     const paintEntries = performance.getEntriesByType('paint');
                     const fpEntry = paintEntries && paintEntries.find(entry => entry.name === 'first-paint');
                     const paintTimeOrigin = performance.timeOrigin || 0;
                     const fallbackTime = timing.loadEventEnd || timing.domContentLoadedEventEnd || 0;

                     const calculatedTime = fpEntry && fpEntry.startTime !== undefined
                       ? (fpEntry.startTime + paintTimeOrigin) / 1000
                       : (fallbackTime > 0 ? (fallbackTime + paintTimeOrigin) / 1000 : paintTimeOrigin / 1000);

                     return toFixed(calculatedTime, 3);
                 } catch(e) {
                     return toFixed((performance.timeOrigin || 0)/1000, 3);
                 }
              }
            }
             try {
                window.chrome.loadTimes = function() {
                return {
                    ...protocolInfo,
                    ...timingInfo
                }
                }
                utils.patchToString(window.chrome.loadTimes)
             } catch(e){}
          }`,
       args: [{ opts: {} }]
     },
     {
       mainFunction: `(utils, profile, { opts, STATIC_DATA }) => {
            if (!window.chrome) {
                 try {
                    Object.defineProperty(window, 'chrome', {
                    writable: true,
                    enumerable: true,
                    configurable: false,
                    value: {}
                    })
                 } catch(e){}
            }
            const existsAlready = window.chrome && 'runtime' in window.chrome
            const isNotSecure = !window.location.protocol.startsWith('https')
            if (existsAlready || (isNotSecure && !(opts && opts.runOnInsecureOrigins))) { // Check opts exists
              return
            }
             try{
                window.chrome.runtime = {
                ...STATIC_DATA,
                get id() {
                    return undefined
                },
                connect: null,
                sendMessage: null
                }
             } catch(e){ return; } // Stop if runtime cannot be assigned

            const makeCustomRuntimeErrors = (preamble, method, extensionId) => ({
              NoMatchingSignature: new TypeError(
                preamble + \`No matching signature.\`
              ),
              MustSpecifyExtensionID: new TypeError(
                preamble +
                  \`\${method} called from a webpage must specify an Extension ID (string) for its first argument.\`
              ),
              InvalidExtensionID: new TypeError(
                preamble + \`Invalid extension id: '\${extensionId || ''}'\` // Handle undefined extensionId
              )
            })
            const isValidExtensionID = str =>
              typeof str === 'string' && str.length === 32 && str.toLowerCase().match(/^[a-p]+$/) // Check type

            const sendMessageHandler = {
              apply: function(target, ctx, args) {
                const [extensionId, options, responseCallback] = args || []
                const errorPreamble = \`Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): \`
                const Errors = makeCustomRuntimeErrors(
                  errorPreamble,
                  \`chrome.runtime.sendMessage()\`,
                  extensionId
                )
                const argCount = args ? args.length : 0;
                const noArguments = argCount === 0
                const tooManyArguments = argCount > 4
                const incorrectOptions = options && typeof options !== 'object'
                const incorrectResponseCallback =
                  responseCallback && typeof responseCallback !== 'function'
                if (
                  noArguments ||
                  tooManyArguments ||
                  incorrectOptions ||
                  incorrectResponseCallback
                ) {
                  throw Errors.NoMatchingSignature
                }
                if (argCount < 2) {
                  throw Errors.MustSpecifyExtensionID
                }
                if (typeof extensionId !== 'string') {
                  throw Errors.NoMatchingSignature
                }
                if (!isValidExtensionID(extensionId)) {
                  throw Errors.InvalidExtensionID
                }
                return undefined
              }
            }
            utils.mockWithProxy(
              window.chrome.runtime,
              'sendMessage',
              function sendMessage() {},
              sendMessageHandler
            )
            const connectHandler = {
              apply: function(target, ctx, args) {
                const [extensionId, connectInfo] = args || []
                 const argCount = args ? args.length : 0;
                const errorPreamble = \`Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): \`
                const Errors = makeCustomRuntimeErrors(
                  errorPreamble,
                  \`chrome.runtime.connect()\`,
                  extensionId
                )
                const noArguments = argCount === 0
                const emptyStringArgument = argCount === 1 && extensionId === ''
                if (noArguments || emptyStringArgument) {
                  throw Errors.MustSpecifyExtensionID
                }
                const tooManyArguments = argCount > 2
                const incorrectConnectInfoType =
                  connectInfo && typeof connectInfo !== 'object'
                if (tooManyArguments || incorrectConnectInfoType) {
                  throw Errors.NoMatchingSignature
                }
                const extensionIdIsString = typeof extensionId === 'string'
                if (extensionIdIsString && extensionId === '') {
                  throw Errors.MustSpecifyExtensionID
                }
                if (extensionIdIsString && !isValidExtensionID(extensionId)) {
                  throw Errors.InvalidExtensionID
                }
                const validateConnectInfo = ci => {
                  if (argCount > 1) {
                    throw Errors.NoMatchingSignature
                  }
                   if (!ci || typeof ci !== 'object' || Object.keys(ci).length === 0) { // Check if ci is a valid object
                      throw Errors.MustSpecifyExtensionID;
                   }
                  Object.entries(ci).forEach(([k, v]) => {
                    const isExpected = ['name', 'includeTlsChannelId'].includes(k)
                    if (!isExpected) {
                      throw new TypeError(
                        errorPreamble + \`Unexpected property: '\${k}'.\`
                      )
                    }
                    const MismatchError = (propName, expected, found) =>
                      TypeError(
                        errorPreamble +
                          \`Error at property '\${propName}': Invalid type: expected \${expected}, found \${typeof v}.\` // Use typeof v
                      )
                    if (k === 'name' && typeof v !== 'string') {
                      throw MismatchError(k, 'string', typeof v)
                    }
                    if (k === 'includeTlsChannelId' && typeof v !== 'boolean') {
                      throw MismatchError(k, 'boolean', typeof v)
                    }
                  })
                }
                if (typeof extensionId === 'object' && extensionId !== null) { // Check for null
                  validateConnectInfo(extensionId)
                  throw Errors.MustSpecifyExtensionID
                }
                return utils.patchToStringNested(makeConnectResponse())
              }
            }
            utils.mockWithProxy(
              window.chrome.runtime,
              'connect',
              function connect() {},
              connectHandler
            )
            function makeConnectResponse() {
              const onSomething = () => ({
                addListener: function addListener() {},
                dispatch: function dispatch() {},
                hasListener: function hasListener() { return false; }, // Return boolean
                hasListeners: function hasListeners() {
                  return false
                },
                removeListener: function removeListener() {}
              })
              const response = {
                name: '',
                sender: undefined,
                disconnect: function disconnect() {},
                onDisconnect: onSomething(),
                onMessage: onSomething(),
                postMessage: function postMessage() {
                   // Check if port is disconnected conceptually (more robust than relying on exception)
                   // This is a simplification; real implementation might have an internal state.
                   if (this._disconnected) { // Hypothetical internal state
                       throw new Error('Attempting to use a disconnected port object');
                   }
                  if (!arguments.length) {
                    throw new TypeError(\`Insufficient number of arguments.\`)
                  }
                   // Normal behavior would send the message
                },
                _disconnected: false // Hypothetical state for postMessage check
              }
               // Add disconnect logic to the disconnect function
               response.disconnect = function() {
                   this._disconnected = true;
                   // Trigger onDisconnect listeners (simplified)
                   if (this.onDisconnect && typeof this.onDisconnect.dispatch === 'function') {
                        try { this.onDisconnect.dispatch(); } catch(e){}
                   }
               }.bind(response); // Bind 'this'
              return response
            }
          }`,
       args: [{ opts: { runOnInsecureOrigins: false }, STATIC_DATA: { OnInstalledReason: { CHROME_UPDATE: "chrome_update", INSTALL: "install", SHARED_MODULE_UPDATE: "shared_module_update", UPDATE: "update" }, OnRestartRequiredReason: { APP_UPDATE: "app_update", OS_UPDATE: "os_update", PERIODIC: "periodic" }, PlatformArch: { ARM: "arm", ARM64: "arm64", MIPS: "mips", MIPS64: "mips64", X86_32: "x86-32", X86_64: "x86-64" }, PlatformNaclArch: { ARM: "arm", MIPS: "mips", MIPS64: "mips64", X86_32: "x86-32", X86_64: "x86-64" }, PlatformOs: { ANDROID: "android", CROS: "cros", LINUX: "linux", MAC: "mac", OPENBSD: "openbsd", WIN: "win" }, RequestUpdateCheckStatus: { NO_UPDATE: "no_update", THROTTLED: "throttled", UPDATE_AVAILABLE: "update_available" } } }]
     },
     {
        mainFunction: `(utils, profile) => {
            const parseInput = arg => {
               if (typeof arg !== 'string') return { mime: '', codecStr: '', codecs: [] }; // Handle non-string input
              const [mime, codecStr] = arg.trim().split(';')
              let codecs = []
              if (codecStr && codecStr.includes('codecs=\"')) {
                try { // Add try-catch for robust parsing
                    codecs = codecStr
                    .trim()
                    .replace(\`codecs=\"\`, '')
                    .replace(/^\\"|\\"$/g, '') // More robust quote removal
                    .split(',')
                    .map(x => x.trim()) // Trim spaces
                    .filter(x => !!x)
                } catch(e) { codecs = []; }
              }
              return {
                mime: mime || '', // Ensure mime is a string
                codecStr: codecStr || '',
                codecs
              }
            }
            const canPlayType = {
              apply: function(target, ctx, args) {
                 // Always return 'probably' or 'maybe' or '' (empty string)
                const defaultApply = () => {
                    try {
                        const result = target.apply(ctx, args);
                        // Normalize to standard return values
                        if (result === 'probably' || result === 'maybe') return result;
                        return ''; // Default to empty string if not 'probably' or 'maybe'
                    } catch (e) {
                        return ''; // Return empty string on error
                    }
                };

                if (!args || !args.length || typeof args[0] !== 'string') {
                    return defaultApply();
                }

                const { mime, codecs } = parseInput(args[0])

                 // Specific overrides:
                if (mime === 'video/mp4') {
                    if (codecs.some(c => c.startsWith('avc1.42E01E'))) { // Check prefix for flexibility
                        return 'probably'
                    }
                }
                 if (mime === 'audio/x-m4a' && codecs.length === 0) {
                    return 'maybe'
                 }

                 if (mime === 'audio/aac' && codecs.length === 0) {
                    return 'probably'
                 }

                  // Add more overrides based on common browser capabilities if needed
                  // e.g., WebM with VP9/Opus is usually 'probably'
                 if (mime === 'video/webm' && codecs.includes('vp9') && codecs.includes('opus')) {
                      return 'probably';
                 }
                 if (mime === 'audio/ogg' && codecs.includes('vorbis')) {
                      return 'maybe'; // Ogg Vorbis support can be 'maybe'
                 }


                // Fallback to original method but normalize result
                return defaultApply();
              }
            }
            if (typeof HTMLMediaElement !== 'undefined' && HTMLMediaElement.prototype && HTMLMediaElement.prototype.canPlayType) {
                 utils.replaceWithProxy(
                    HTMLMediaElement.prototype,
                    'canPlayType',
                    canPlayType
                  )
            }
          }`,
        args: []
      },
      {
         mainFunction: `(utils, profile) => {
               const hardwareConcurrency = profile.hardwareConcurrency || 4; // Default to 4 if not in profile
               try {
                   // Check if property exists directly on navigator or its prototype
                   let targetObj = null;
                   if (navigator && 'hardwareConcurrency' in navigator) {
                        targetObj = navigator;
                   } else if (typeof Navigator !== 'undefined' && Navigator.prototype && 'hardwareConcurrency' in Navigator.prototype) {
                       targetObj = Object.getPrototypeOf(navigator);
                   }

                   if (targetObj && Object.getOwnPropertyDescriptor(targetObj, 'hardwareConcurrency')?.get) {
                        utils.replaceGetterWithProxy(
                             targetObj, // Use the determined target object
                             'hardwareConcurrency',
                             utils.makeHandler().getterValue(hardwareConcurrency)
                        );
                   } else if (targetObj) {
                        // If it exists but isn't a getter, try direct defineProperty (less common)
                         Object.defineProperty(targetObj, 'hardwareConcurrency', {
                            value: hardwareConcurrency,
                            writable: false, // Or true depending on desired behavior
                            enumerable: true,
                            configurable: true // Important to allow potential future modifications
                         });
                   } else {
                       // If it doesn't exist anywhere, define it on navigator directly
                       Object.defineProperty(navigator, 'hardwareConcurrency', {
                            value: hardwareConcurrency,
                            writable: false,
                            enumerable: true,
                            configurable: true
                         });
                   }
               } catch(e) {} // Ignore errors if modification fails
            }`,
         args: []
       },
       {
          mainFunction: `(utils, profile) => {
               const languages = (profile.languages && profile.languages.length)
                 ? profile.languages
                 : ['en-US', 'en'];
               const languagesFrozen = Object.freeze([...languages]); // Freeze the array

               try {
                   // Check if property exists directly on navigator or its prototype
                   let targetObj = null;
                   if (navigator && 'languages' in navigator) {
                        targetObj = navigator;
                   } else if (typeof Navigator !== 'undefined' && Navigator.prototype && 'languages' in Navigator.prototype) {
                       targetObj = Object.getPrototypeOf(navigator);
                   }

                   if (targetObj && Object.getOwnPropertyDescriptor(targetObj, 'languages')?.get) {
                        utils.replaceGetterWithProxy(
                            targetObj,
                            'languages',
                            utils.makeHandler().getterValue(languagesFrozen) // Use frozen array
                        );
                   } else if (targetObj) {
                       // If it exists but isn't a getter, try direct defineProperty
                       Object.defineProperty(targetObj, 'languages', {
                           value: languagesFrozen,
                           writable: false, // Languages are typically read-only
                           enumerable: true,
                           configurable: true
                       });
                   } else {
                       // Define on navigator directly if it doesn't exist
                       Object.defineProperty(navigator, 'languages', {
                            value: languagesFrozen,
                            writable: false,
                            enumerable: true,
                            configurable: true
                         });
                   }
               } catch (e) {} // Ignore errors
             }`,
          args: []
        },
        { // New Evasion: navigator.userAgent
           mainFunction: `(utils, profile) => {
               const userAgent = profile.userAgent || 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'; // Fallback UA
               try {
                   // Check if property exists directly on navigator or its prototype
                   let targetObj = null;
                    if (navigator && navigator.hasOwnProperty('userAgent')) { // Check own property first
                        targetObj = navigator;
                    } else if (typeof Navigator !== 'undefined' && Navigator.prototype && Object.prototype.hasOwnProperty.call(Navigator.prototype, 'userAgent')) {
                       targetObj = Object.getPrototypeOf(navigator);
                   }


                   if (targetObj && Object.getOwnPropertyDescriptor(targetObj, 'userAgent')?.get) {
                       utils.replaceGetterWithProxy(
                           targetObj,
                           'userAgent',
                           utils.makeHandler().getterValue(userAgent)
                       );
                    } else if (targetObj) {
                         // If it exists but isn't a getter (unlikely for userAgent, but handle defensively)
                        Object.defineProperty(targetObj, 'userAgent', {
                            value: userAgent,
                            writable: false, // UserAgent is typically read-only
                            enumerable: true,
                            configurable: true // Make configurable to allow potential reverts/changes
                        });
                    } else {
                       // If it doesn't exist anywhere (highly unusual), define it on navigator directly
                       Object.defineProperty(navigator, 'userAgent', {
                            value: userAgent,
                            writable: false,
                            enumerable: true,
                            configurable: true
                         });
                    }
               } catch(e) {} // Ignore errors
           }`,
           args: []
        },
         { // New Evasion: navigator.deviceMemory
           mainFunction: `(utils, profile) => {
               const deviceMemory = profile.deviceMemory || 8; // Default to 8GB if not in profile
               try {
                    // Check if property exists directly on navigator or its prototype
                   let targetObj = null;
                   if (navigator && 'deviceMemory' in navigator) {
                        targetObj = navigator;
                   } else if (typeof Navigator !== 'undefined' && Navigator.prototype && 'deviceMemory' in Navigator.prototype) {
                       targetObj = Object.getPrototypeOf(navigator);
                   }

                   if (targetObj && Object.getOwnPropertyDescriptor(targetObj, 'deviceMemory')?.get) {
                        utils.replaceGetterWithProxy(
                            targetObj,
                            'deviceMemory',
                            utils.makeHandler().getterValue(deviceMemory)
                        );
                   } else if (targetObj){
                        // If it exists but isn't a getter
                        Object.defineProperty(targetObj, 'deviceMemory', {
                            value: deviceMemory,
                            writable: false, // deviceMemory is read-only
                            enumerable: true,
                            configurable: true
                        });
                   } else {
                       // Define on navigator directly if it doesn't exist
                       Object.defineProperty(navigator, 'deviceMemory', {
                            value: deviceMemory,
                            writable: false,
                            enumerable: true,
                            configurable: true
                         });
                   }
               } catch(e) {} // Ignore errors
           }`,
           args: []
        },
        {
           mainFunction: `(utils, profile) => {
                const isSecure = window.location.protocol.startsWith('https')

                // Notification.permission override
                if (isSecure) {
                    if (typeof Notification !== 'undefined' && Notification.prototype){
                        try{
                            // Ensure 'permission' exists and is a getter before trying to replace
                             const descriptor = Object.getOwnPropertyDescriptor(Notification, 'permission');
                             if (descriptor && descriptor.get) {
                                 utils.replaceGetterWithProxy(Notification, 'permission', {
                                    apply() {
                                        return 'default'
                                    }
                                });
                             } else if (descriptor) {
                                 // If it exists but not as a getter, overwrite (less ideal)
                                 Object.defineProperty(Notification, 'permission', { value: 'default', writable: false, enumerable: true, configurable: true });
                             } else {
                                 // If it doesn't exist, define it
                                 Object.defineProperty(Notification, 'permission', { value: 'default', writable: false, enumerable: true, configurable: true });
                             }
                        } catch(e){}
                    }
                }

                // Permissions.query override for insecure origins
                if (!isSecure) {
                  const handler = {
                    apply(target, ctx, args) {
                      const param = (args || [])[0]
                      const isNotifications =
                        param && typeof param === 'object' && param.name === 'notifications'; // Check type

                      // Call original function if not 'notifications' or if PermissionStatus is unavailable
                      if (!isNotifications || typeof PermissionStatus === 'undefined') {
                         try {
                           return utils.cache.Reflect.apply(target, ctx, args) // Use Reflect.apply correctly
                         } catch(e) {
                            return Promise.reject(new DOMException('Operation unsupported', 'NotSupportedError')); // Standard rejection
                         }
                      }

                       // Create a mock PermissionStatus object
                      try {
                           const mockStatus = {
                                state: 'denied',
                                onchange: null,
                                // Mock methods expected on PermissionStatus instances
                                addEventListener: function() {},
                                removeEventListener: function() {},
                                dispatchEvent: function() { return true; }
                           };
                           // Set the prototype to PermissionStatus.prototype
                           Object.setPrototypeOf(mockStatus, PermissionStatus.prototype);
                           return Promise.resolve(mockStatus);
                      } catch(e) {
                           return Promise.reject(new DOMException('Failed to create mock PermissionStatus', 'OperationError'));
                      }
                    }
                  }
                   // Check if Permissions API and its prototype method exist
                  if (typeof Permissions !== 'undefined' && Permissions.prototype && typeof Permissions.prototype.query === 'function'){
                       utils.replaceWithProxy(Permissions.prototype, 'query', handler)
                  }
                }
              }`,
           args: [{}]
         },
         {
           mainFunction: `(utils, profile, { fns, data }) => {
                try {
                    fns = utils.materializeFns(fns)
                    const hasPlugins = navigator && typeof navigator.plugins !== 'undefined' && navigator.plugins.length > 0;
                    const hasMimeTypes = navigator && typeof navigator.mimeTypes !== 'undefined' && navigator.mimeTypes.length > 0;

                     // Determine data source: Profile overrides default
                     const useProfileData = profile && profile.plugins && profile.mimeTypes;
                     const mimeTypesData = useProfileData ? profile.mimeTypes : data.mimeTypes;
                     const pluginsData = useProfileData ? profile.plugins : data.plugins;

                    // Only run if plugins/mimeTypes are naturally empty OR profile provides data
                    if ((!hasPlugins && !hasMimeTypes) || useProfileData) {
                        const mimeTypes = fns.generateMimeTypeArray(utils, fns)(mimeTypesData || []); // Pass empty array if data missing
                        const plugins = fns.generatePluginArray(utils, fns)(pluginsData || []);     // Pass empty array if data missing

                        // Cross-linking (defensive checks added)
                         if (pluginsData && mimeTypesData && plugins && mimeTypes) {
                             for (const pluginData of pluginsData) {
                                if (!pluginData || !plugins[pluginData.name] || !Array.isArray(pluginData.__mimeTypes)) continue;

                                pluginData.__mimeTypes.forEach((type, index) => {
                                    if (!type || !mimeTypes[type]) return;

                                    try {
                                        plugins[pluginData.name][index] = mimeTypes[type]

                                        Object.defineProperty(plugins[pluginData.name], type, {
                                            value: mimeTypes[type],
                                            writable: false,
                                            enumerable: false,
                                            configurable: true
                                        });

                                        // Handle potential circularity and missing mimeTypes gracefully
                                        let enabledPluginValue = null;
                                        if (type === 'application/x-pnacl' && mimeTypes['application/x-nacl']?.enabledPlugin) {
                                            enabledPluginValue = mimeTypes['application/x-nacl'].enabledPlugin;
                                        } else if (plugins[pluginData.name]) {
                                             // Create a new proxy only if needed, avoid direct circular reference
                                             enabledPluginValue = new Proxy(plugins[pluginData.name], {});
                                        }

                                        if (enabledPluginValue !== null) {
                                            Object.defineProperty(mimeTypes[type], 'enabledPlugin', {
                                                value: enabledPluginValue,
                                                writable: false,
                                                enumerable: false,
                                                configurable: true
                                            });
                                        }
                                    } catch(e) { } // Ignore definition errors
                                })
                            }
                         }


                        const patchNavigator = (name, value) => {
                            try {
                                let targetObj = null;
                                // Prefer patching prototype if possible
                                if (typeof Navigator !== 'undefined' && Navigator.prototype && Object.prototype.hasOwnProperty.call(Navigator.prototype, name)) {
                                    targetObj = Object.getPrototypeOf(navigator);
                                } else if (navigator && Object.prototype.hasOwnProperty.call(navigator, name)) {
                                    // Fallback to patching navigator directly if owned property
                                    targetObj = navigator;
                                }

                                if (targetObj) {
                                    utils.replaceProperty(targetObj, name, {
                                        get() { return value; },
                                        enumerable: true, // Make sure it's enumerable
                                        configurable: true // Allow potential future changes
                                    });
                                } else if (navigator) {
                                    // If not found on proto or self, define directly on navigator
                                    Object.defineProperty(navigator, name, {
                                         get() { return value; },
                                         enumerable: true,
                                         configurable: true
                                    });
                                }
                            } catch (e) { } // Ignore errors
                        }

                        patchNavigator('mimeTypes', mimeTypes)
                        patchNavigator('plugins', plugins)
                    }
                 } catch(e) {} // Catch errors in the main block
              }`,
           args: [{
             fns: {
               generateMimeTypeArray: `(utils, fns) => mimeTypesData => {\n  try { return fns.generateMagicArray(utils, fns)(\n    mimeTypesData,\n    typeof MimeTypeArray !== 'undefined' ? MimeTypeArray.prototype : undefined,\n    typeof MimeType !== 'undefined' ? MimeType.prototype : undefined,\n    'type'\n  )} catch(e) { return []; }\n}`,
               generatePluginArray: `(utils, fns) => pluginsData => {\n  try { return fns.generateMagicArray(utils, fns)(\n    pluginsData,\n    typeof PluginArray !== 'undefined' ? PluginArray.prototype : undefined,\n    typeof Plugin !== 'undefined' ? Plugin.prototype : undefined,\n    'name'\n  )} catch(e) { return []; }\n}`,
               generateMagicArray: `(utils, fns) =>\n  function(\n    dataArray = [],\n    proto,\n    itemProto,\n    itemMainProp = 'type'\n  ) {\n   if(!proto || !itemProto) { return []; } // Exit if prototypes are missing\n   try {\n    const defineProp = (obj, prop, value) =>\n       {\n         try {\n             Object.defineProperty(obj, prop, {\n                value,\n                writable: false,\n                enumerable: false, \n                configurable: true\n             })\n         } catch(e) {} // Ignore defineProperty errors\n        }\n\n    const makeItem = data => {\n      const item = {}\n       if (!data) return item; // Handle null/undefined data\n      for (const prop of Object.keys(data)) {\n        if (prop.startsWith('__')) {\n          continue\n        }\n        defineProp(item, prop, data[prop])\n      }\n      return patchItem(item, data)\n    }\n\n    const patchItem = (item, data) => {\n      let descriptor = {};\n      try { descriptor = Object.getOwnPropertyDescriptors(item) } catch(e) {}\n\n      if (itemProto === Plugin.prototype) {\n        descriptor = {\n          ...descriptor,\n          length: {\n            value: (data && data.__mimeTypes) ? data.__mimeTypes.length : 0, // Check data and __mimeTypes\n            writable: false,\n            enumerable: false,\n            configurable: true \n          }\n        }\n      }\n\n       let obj = {};\n       try { obj = Object.create(itemProto, descriptor); } catch(e) { obj = {...item}; } // Fallback if create fails\n\n      const blacklist = [...(data ? Object.keys(data) : []), 'length', 'enabledPlugin'];\n      return new Proxy(obj, {\n        ownKeys(target) {\n          try { return Reflect.ownKeys(target).filter(k => !blacklist.includes(k)) } catch(e) { return []; }\n        },\n        getOwnPropertyDescriptor(target, prop) {\n          try {\n             if (blacklist.includes(prop)) {\n                return undefined\n             }\n             return Reflect.getOwnPropertyDescriptor(target, prop)\n          } catch(e) { return undefined; }\n        }\n      })\n    }\n\n    const magicArray = []\n    if(Array.isArray(dataArray)) {\n        dataArray.forEach(data => {\n         if(data) { magicArray.push(makeItem(data)); } // Check data validity\n        })\n    }\n\n    magicArray.forEach(entry => {\n       if (entry && entry[itemMainProp]) {\n           defineProp(magicArray, entry[itemMainProp], entry);\n       }\n    })\n\n     let magicArrayObj;\n     try { magicArrayObj = Object.create(proto, {\n         ...Object.getOwnPropertyDescriptors(magicArray),\n         length: {\n            value: magicArray.length,\n            writable: false,\n            enumerable: false,\n            configurable: true \n         }\n         });\n     } catch(e) { magicArrayObj = [...magicArray]; magicArrayObj.length = magicArray.length; } // Fallback\n\n    const functionMocks = fns.generateFunctionMocks(utils)(\n      proto,\n      itemMainProp,\n      magicArray\n    )\n\n    const magicArrayObjProxy = new Proxy(magicArrayObj, {\n      get(target, key = '') {\n        try {\n            if (key === 'item' && functionMocks && functionMocks.item) {\n            return functionMocks.item\n            }\n            if (key === 'namedItem' && functionMocks && functionMocks.namedItem) {\n            return functionMocks.namedItem\n            }\n            if (proto === PluginArray.prototype && key === 'refresh' && functionMocks && functionMocks.refresh) {\n            return functionMocks.refresh\n            }\n            return utils.cache.Reflect.get(target, key)\n        } catch(e) { return undefined; } \n      },\n      ownKeys(target) {\n         try {\n            const keys = []\n            const typeProps = magicArray.map(mt => mt ? mt[itemMainProp] : undefined).filter(Boolean);\n            typeProps.forEach((_, i) => keys.push(\`\${i}\`))\n            typeProps.forEach(propName => keys.push(propName))\n            return keys\n         } catch(e) { return []; }\n      },\n      getOwnPropertyDescriptor(target, prop) {\n          try {\n             if (prop === 'length') {\n                return undefined\n             }\n             return Reflect.getOwnPropertyDescriptor(target, prop)\n          } catch(e) { return undefined; }\n      }\n    })\n\n    return magicArrayObjProxy\n   } catch(e) { return []; } // Catch errors in the main function body\n  }`,
               generateFunctionMocks: `utils => (\n  proto,\n  itemMainProp,\n  dataArray\n) => {\n   if (!proto || !proto.item || !proto.namedItem || !utils || !utils.createProxy) {\n       return {};\n   }\n try{\n  return {\n  item: utils.createProxy(proto.item, {\n    apply(target, ctx, args) {\n       try {\n            if (!args || !args.length) {\n                throw new TypeError(\n                \`Failed to execute 'item' on '\${proto[Symbol.toStringTag] || 'Object'}': 1 argument required, but only 0 present.\`\n                )\n            }\n            const index = args[0];\n            const isInteger = typeof index === 'number' && Number.isInteger(index);\n            const isStringInteger = typeof index === 'string' && Number.isInteger(Number(index)) && String(Number(index)) === index;\n\n            if (isInteger || isStringInteger) {\n                 return dataArray[Number(index)] || null;\n            }\n            // Quirky behavior: non-integer/non-string-integer returns the first item\n             return dataArray[0] || null;\n       } catch(e) { return null; }\n    }\n  }),\n  namedItem: utils.createProxy(proto.namedItem, {\n    apply(target, ctx, args) {\n      try {\n          if (!args || !args.length) {\n            throw new TypeError(\n              \`Failed to execute 'namedItem' on '\${proto[Symbol.toStringTag] || 'Object'}': 1 argument required, but only 0 present.\`\n            )\n          }\n          const name = args[0];\n          if (typeof name !== 'string') { return null; } // Must be a string\n          return dataArray.find(mt => mt && mt[itemMainProp] === name) || null \n      } catch(e) { return null; }\n    }\n  }),\n  refresh: proto.refresh\n    ? utils.createProxy(proto.refresh, {\n        apply(target, ctx, args) {\n          return undefined\n        }\n      })\n    : undefined\n}} catch(e) { return {} } \n}`
             },
              data: { // Default data (used if profile doesn't provide overrides)
                mimeTypes: [
                  {type:"application/pdf",suffixes:"pdf",description:"",__pluginName:"Chrome PDF Viewer"},
                  {type:"application/x-google-chrome-pdf",suffixes:"pdf",description:"Portable Document Format",__pluginName:"Chrome PDF Plugin"},
                  {type:"application/x-nacl",suffixes:"",description:"Native Client Executable",__pluginName:"Native Client"},
                  {type:"application/x-pnacl",suffixes:"",description:"Portable Native Client Executable",__pluginName:"Native Client"}
                ],
                plugins: [
                  {name:"Chrome PDF Plugin",filename:"internal-pdf-viewer",description:"Portable Document Format",__mimeTypes:["application/x-google-chrome-pdf"]},
                  {name:"Chrome PDF Viewer",filename:"mhjfbmdgcfjbbpaeojofohoefgiehjai",description:"",__mimeTypes:["application/pdf"]},
                  {name:"Native Client",filename:"internal-nacl-plugin",description:"",__mimeTypes:["application/x-nacl","application/x-pnacl"]}
                ]
              }
           }]
         },
         {
            mainFunction: `(utils, profile) => {
                try {
                    // Check if navigator.webdriver exists and get its value safely
                    let webdriverValue = undefined;
                    if (navigator && 'webdriver' in navigator) {
                        webdriverValue = navigator.webdriver;
                    }

                    // Only delete if it's explicitly true
                    if (webdriverValue === true) {
                         let deleted = false;
                         // Try deleting from prototype first
                         if (typeof Navigator !== 'undefined' && Navigator.prototype && Object.prototype.hasOwnProperty.call(Navigator.prototype, 'webdriver')) {
                             try {
                                deleted = delete Object.getPrototypeOf(navigator).webdriver;
                             } catch(e){}
                         }
                         // If not deleted from prototype or if it was an own property, try deleting directly
                         if (!deleted && navigator && Object.prototype.hasOwnProperty.call(navigator, 'webdriver')) {
                             try { delete navigator.webdriver; } catch(e) {}
                         }
                    }
                    // If it's already false or undefined, do nothing.
                } catch(e) {} // Ignore errors
             }`,
            args: []
          },
          {
            mainFunction: `(utils, profile) => {
                 try {
                   const getParameterProxyHandler = {
                     apply: function(target, ctx, args) {
                       const param = (args || [])[0]
                       let result = undefined;
                        try { result = utils.cache.Reflect.apply(target, ctx, args) } catch(e){} // Get original result safely

                       // UNMASKED_VENDOR_WEBGL
                       if (param === 37445) {
                         return profile.webglVendor || 'Intel Inc.'
                       }
                       // UNMASKED_RENDERER_WEBGL
                       if (param === 37446) {
                         return profile.webglRenderer || 'Intel Iris OpenGL Engine'
                       }
                       return result // Return original result for other params
                     }
                   }

                   const addProxy = (contextPrototype, propName) => {
                      try {
                          if (contextPrototype && typeof contextPrototype[propName] === 'function') {
                              utils.replaceWithProxy(contextPrototype, propName, getParameterProxyHandler)
                          }
                      } catch(e) {} // Ignore errors for specific context/property
                   }

                  // Get prototypes safely
                  const WGLRC = (typeof WebGLRenderingContext !== 'undefined') ? WebGLRenderingContext.prototype : null;
                  const WGL2RC = (typeof WebGL2RenderingContext !== 'undefined') ? WebGL2RenderingContext.prototype : null;

                  addProxy(WGLRC, 'getParameter');
                  addProxy(WGL2RC, 'getParameter');

                 } catch (err) {
                   // console.warn('WebGL spoofing failed:', err) // Keep console logs commented out
                 }
               }`,
            args: []
          },
          {
             mainFunction: `(utils, profile) => {
                  try {
                    // Only run if outer dimensions are zero or missing (common in headless)
                    if ((!window.outerWidth || !window.outerHeight) && window.innerWidth && window.innerHeight) {
                         const offset = profile.outerHeightOffset || 85;
                         window.outerWidth = window.innerWidth;
                         window.outerHeight = window.innerHeight + offset;
                    }
                  } catch (err) {} // Ignore errors
                }`,
             args: []
           },
           {
             mainFunction: `(utils, profile) => {
                  try {
                    const addContentWindowProxy = iframe => {
                       try {
                           // Skip if contentWindow is already accessible (likely same-origin or already proxied)
                           if (iframe.contentWindow && iframe.contentWindow.self) {
                                // Check if it's already our proxy to prevent re-proxying
                                if (iframe.contentWindow.frameElement === iframe) return;
                           }
                       } catch (e) {
                           // SecurityError likely means cross-origin, don't proxy
                           if (e.name === 'SecurityError') return;
                       }

                      const contentWindowProxyHandler = {
                         get(target, key, receiver) { // Add receiver
                             // Use receiver for 'self' check
                             if (key === 'self') return receiver; // The proxy itself is 'self'

                             if (key === 'frameElement') return iframe;
                             if (key === '0') return undefined; // Hide proxy index

                             // Prevent TypeError on null/undefined target (though target is 'window' here)
                             if (target === null || typeof target === 'undefined') return undefined;

                             try {
                                 // Important: Use original 'window' as the context for Reflect.get
                                 const value = Reflect.get(window, key);
                                 // If the property is a function, bind it to the original window context
                                 if (typeof value === 'function') {
                                      return value.bind(window);
                                 }
                                 return value;
                             } catch (e) { return undefined; }
                         },
                         // Add 'has' trap to correctly report properties existence on original window
                         has(target, key) {
                            if (key === 'self' || key === 'frameElement') return true;
                             try { return Reflect.has(window, key); } catch(e) { return false; }
                         },
                         // Add set trap to forward writes to original window (might be blocked by browser security)
                         set(target, key, value, receiver) {
                             try {
                                 return Reflect.set(window, key, value);
                             } catch(e) { return false; /* Indicate failure */ }
                         }
                      };

                       // Define proxy using 'window' as the base target
                       try {
                            const proxy = new Proxy(window, contentWindowProxyHandler);
                            Object.defineProperty(iframe, 'contentWindow', {
                                get() { return proxy; },
                                set(newValue) { return newValue; }, // Make setter a no-op
                                enumerable: true,
                                configurable: false
                            });
                       } catch(e) {} // Ignore if defineProperty fails

                    } // End addContentWindowProxy

                    const handleIframeCreation = (target, thisArg, args) => {
                      let iframe = null;
                      try { iframe = target.apply(thisArg, args); } catch(e) { return document.createElement('iframe'); } // Basic fallback

                      // Proxy only if it's likely same-origin (srcdoc or no src)
                      if (iframe && (iframe.srcdoc || !iframe.src)) {
                            addContentWindowProxy(iframe);

                            // Monitor srcdoc changes (simplified)
                            const _iframe = iframe;
                            let _srcdoc = _iframe.srcdoc || '';
                            try {
                                Object.defineProperty(iframe, 'srcdoc', {
                                    configurable: true, // Keep configurable
                                    get: function() { return _srcdoc; },
                                    set: function(newValue) {
                                        _srcdoc = newValue;
                                        addContentWindowProxy(this); // Re-apply proxy if needed
                                        // Use setAttribute to trigger browser behavior for srcdoc updates
                                        if (_iframe.setAttribute) {
                                            try { _iframe.setAttribute('srcdoc', newValue); } catch(e){}
                                        }
                                    }
                                });
                            } catch(e) {} // Ignore defineProperty error
                      }
                      return iframe;
                    } // End handleIframeCreation

                    const addIframeCreationSniffer = () => {
                       if (!document || typeof document.createElement !== 'function') return;

                      const originalCreateElement = document.createElement;
                      const createElementHandler = {
                         get(target, key) {
                            if (key === 'toString') {
                                try { return originalCreateElement.toString.bind(originalCreateElement); } catch(e) { return function(){ "[native code]"; } }
                            }
                             try { return Reflect.get(target, key); } catch(e) { return undefined; }
                         },
                         apply: function(target, thisArg, args) {
                            try {
                                const tagName = (args && args.length) ? \`\${args[0]}\`.toLowerCase() : '';
                                if (tagName === 'iframe') {
                                    return handleIframeCreation(target, thisArg, args);
                                } else {
                                    return target.apply(thisArg, args);
                                }
                            } catch(e) {
                                try { return target.apply(thisArg, args); } catch(e2) { return null; } // Ultimate fallback
                            }
                         }
                       };
                       // Use mockWithProxy for potentially better compatibility/toString handling
                       utils.mockWithProxy(document, 'createElement', originalCreateElement, createElementHandler);
                    } // End addIframeCreationSniffer

                    addIframeCreationSniffer()
                  } catch (err) {
                     // console.warn('iframe.contentWindow evasion failed:', err)
                  }
                }`,
             args: []
           },
  ];


  evasions.forEach(evasion => {
    try {
      // Ensure mainFunction is a string before eval
      if (typeof evasion.mainFunction === 'string') {
         const mainFn = eval(evasion.mainFunction);
         // Ensure eval result is a function
         if (typeof mainFn === 'function') {
              // Ensure args is an array
              const args = Array.isArray(evasion.args) ? evasion.args : [];
              const combinedArgs = [utils, selectedProfile, ...args];
              mainFn(...combinedArgs);
         }
      }
    } catch (e) {
      // console.warn('Error running evasion:', e); // Keep commented out
    }
  });

})();